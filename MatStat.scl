FUNCTION_BLOCK MatStat {
                        S7_m_c := 'true';
                        S7_blockview := 'big';
                        S7_tasklist := 'OB100';
                        Scl_OverwriteBlocks := 'y';
                        Scl_CreateObjectCode := 'y';
                        Scl_OptimizeObjectCode := 'y';
                        Scl_MonitorArrayLimits := 'n';
                        Scl_CreateDebugInfo := 'n';
                        Scl_S7ServerActive := 'n';
                        GenerateReferenceData := 'y';
                        SetMaximumStringLength := '254'
                       }
TITLE = 'Material flow stats'
VERSION: '2.7'
AUTHOR: RoVRy
NAME: MatStat
FAMILY: AdvLibRR
KNOW_HOW_PROTECT
(*
===============================================================================
Для корректной работы блока предварительно из библиотеки APL должны быть
импортированы следующие блоки:
IEC/AD_DT_TM_APL [FC455]
IEC/GE_DT_APL [FC456]
IEC/LT_DT_APL [FC453]

Также блок в своей работе использует системные функции:
SFC1 "READ_CLK"
SFC6 "RD_SINFO"
===============================================================================
*)
CONST

    SecArray := 3600;
    SecToSuppress := 300.0;

END_CONST


VAR_INPUT

    PV {
        S7_visible := 'true';
        S7_dynamic := 'true';
        S7_m_c := 'true';
        S7_xm_c := 'Value,true;';
        S7_xqc := 'Value,true;'
       } : STRUCT                                       // Current flow in
             Value : REAL := 0.0;                       // Value
             ST : BYTE := 16#FF;                        // Signal status
           END_STRUCT;

    PV_Unit {
             S7_m_c := 'true';
             S7_visible := 'true';
             S7_unit := ''
            } : INT := 1322;                            // Unit of PV

    Flow_Unit {
                S7_m_c := 'true';
                S7_visible := 'true';
                S7_unit := ''
               } : INT := 1328;                         // Material flow measure unit

    All_Unit {
             S7_m_c := 'true';
             S7_visible := 'true';
             S7_unit := ''
            } : INT := 1092;                            // Material measure unit

    TimeCnv {
             S7_visible := 'true'
            } : REAL := 3600.0;                         // "Time in" to "Time out" factor

    AmountCnv {
               S7_visible := 'true'
              } : REAL := 1000.0;                       // "Amount in' to "Amount out" factor

    TZOffset {
              S7_visible := 'false'
             } : TIME := T#3H;                          // TZ offset for Standard Time

    DSTEn {
           S7_visible := 'false'
          } : BOOL := FALSE;                            // Enable DST advancing during the year

    DSTBegin {
              S7_visible := 'false'
             } : DATE_AND_TIME;                         // Date and time for switch to DST

    DSTEnd {
            S7_visible := 'false'
           } : DATE_AND_TIME;                           // Date and time for return to Standard Time

    DSTOffset {
               S7_visible := 'false'
              } : TIME := T#1H;                         // DST shift

    ChkoutHr {
              S7_visible := 'false'
             } : INT := 0;                              // Checkout hour (necessary for energy accounting)

    CntLiOp {
             S7_visible := 'true'
            } : STRUCT                                  // Count enable via 0 = Operator, 1 = Interconnection or SFC
                  Value : BOOL := FALSE;                // Value
                  ST : BYTE := 16#FF;                   // Signal status
                END_STRUCT;
                
    CntEnLi {
             S7_visible := 'true'
            } : STRUCT                                  // 1 = Count enabled by interconnection or SFC (controlled by CntLiOp = 1)
                  Value : BOOL := TRUE;                 // Value
                  ST : BYTE := 16#FF;                   // Signal status
                END_STRUCT;

    CntEn {
           S7_visible := 'false';
           S7_link := 'false';
           Op_Level := '3';
           S7_m_c := 'true'
          } : BOOL := TRUE;                             // Count enabled from operator

    SimLiOp {
             S7_visible := 'true'
            } : STRUCT                                  // Simulation on/off via 0 = Operator, 1 = Interconnection or SFC
                  Value : BOOL := FALSE;                // Value
                  ST : BYTE := 16#FF;                   // Signal status
                END_STRUCT;

    SimOnLi {
             S7_visible := 'true'
            } : STRUCT                                  // 1 = Simulation activated by interconnection or SFC (controlled by SimLiOp = 1)
                  Value : BOOL := FALSE;                // Value
                  ST : BYTE := 16#FF;                   // Signal status
                END_STRUCT;

    SimOn {
           S7_visible := 'false';
           S7_link := 'false';
           Op_Level := '3';
           S7_m_c := 'true'
          } : BOOL := FALSE;                            // Simulation On/Off

    SimPV_Li {
              S7_visible := 'true'
             } : STRUCT                                 // Linkable simulation value of weight
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal status
                 END_STRUCT;                   

    SimPV {
           S7_visible := 'false';
           S7_link := 'false';
           S7_m_c := 'true';
           Op_Level := '1'
          } : REAL := 0.0;                    // Simulation Value

    RstLi {
           S7_visible := 'true'
          } : STRUCT                                    // Immediate reset all totalizers from external code
                Value : BOOL := FALSE;                  // Value
                ST : BYTE := 16#FF;                     // Signal status
              END_STRUCT;

    RstOp {
           S7_m_c := 'true';
           S7_link := 'false';
           S7_visible := 'false';
           Op_Level := '3'
          } : BOOL := FALSE;                  // Immediate reset all totalizers from faceplate

    UserAna1 {
              S7_m_c := 'true';
              S7_visible := 'false';
              S7_xm_c:='Value,true;';
              S7_xqc:='Value,true;';
              S7_xshortcut := 'Value,;'
             } : STRUCT 
                   Value : REAL := 0.0;
                   ST : BYTE := 16#FF;
                 END_STRUCT;                            // User analog input 1

    UA1Unit {
             S7_visible := 'false';
             S7_m_c := 'true';
             S7_unit := ''
            } : INT := 0;                               // Unit OF UserAna1

    UserAna2 {
              S7_m_c := 'true';
              S7_visible := 'false';
              S7_xm_c:='Value,true;';
              S7_xqc:='Value,true;';
              S7_xshortcut := 'Value,;'
             } : STRUCT
                   Value : REAL := 0.0;
                   ST : BYTE := 16#FF;
                 END_STRUCT;                            // User analog input 2

    UA2Unit {
             S7_visible := 'false';
             S7_m_c := 'true';
             S7_unit := ''
            } : INT := 0;                               // Unit of UserAna2

    SampleTime {
                S7_sampletime := 'true';
                S7_visible := 'false';
                S7_link := 'false'
               } : REAL := 1.0 ;                        // Sampling time [s]

    SelFp1 {
            BLK_Jump := '1';
            S7_visible := 'false'
           } : ANY;                                     // Select Faceplate 1

    SelFp2 {
            BLK_Jump := '1';
            S7_visible := 'false'
           } : ANY;                                     // Select Faceplate 2

    Feature {
             S7_visible := 'false'
            } : STRUCT                                  // Status of various features
                  Bit0 : BOOL := TRUE;                  // 0 = Reset all values; 1 = keep last stored values
                  Bit1 : BOOL := FALSE;                 // 1 = RstOp/RstLi also resets two hours all historical values
                  Bit2 : BOOL := FALSE;                 // 1 = RstOp/RstLi also resets moving average value
                  Bit3 : BOOL := FALSE;                 // 1 = RstOp/RstLi also resets all previous values
                  Bit4 : BOOL := FALSE;                 // 1 = RstOp/RstLi also resets total value
                  Bit5 : BOOL := FALSE;                 // 0 = Linked RstLi will block RstOp, 1 = RstLi and RstOp works side by side
                  Bit6 : BOOL := FALSE;                 // 1 = All negative values will be substituted by zero
                  Bit7 : BOOL := FALSE;
                  Bit8 : BOOL := FALSE;
                  Bit9 : BOOL := FALSE;
                  Bit10 : BOOL := FALSE;
                  Bit11 : BOOL := FALSE;
                  Bit12 : BOOL := FALSE;
                  Bit13 : BOOL := FALSE;
                  Bit14 : BOOL := FALSE;
                  Bit15 : BOOL := FALSE;
                  Bit16 : BOOL := FALSE;
                  Bit17 : BOOL := FALSE;
                  Bit18 : BOOL := FALSE;
                  Bit19 : BOOL := FALSE;
                  Bit20 : BOOL := FALSE;
                  Bit21 : BOOL := FALSE;
                  Bit22 : BOOL := FALSE;
                  Bit23 : BOOL := FALSE;
                  Bit24 : BOOL := FALSE;
                  Bit25 : BOOL := FALSE;
                  Bit26 : BOOL := FALSE;
                  Bit27 : BOOL := FALSE;
                  Bit28 : BOOL := FALSE;
                  Bit29 : BOOL := FALSE;
                  Bit30 : BOOL := FALSE;
                  Bit31 : BOOL := FALSE;
                END_STRUCT;

    OS_Perm {
             S7_visible := 'false'
            } : STRUCT                                  // Operator Permissions
                  Bit0 : BOOL := TRUE;
                  Bit1 : BOOL := TRUE;
                  Bit2 : BOOL := TRUE;
                  Bit3 : BOOL := TRUE;
                  Bit4 : BOOL := TRUE;
                  Bit5 : BOOL := TRUE;                 // 1 = Operator can reset the totalizers
                  Bit6 : BOOL := TRUE;                 // 1 = Operator can change the simulation value SimPV
                  Bit7 : BOOL := TRUE;
                  Bit8 : BOOL := TRUE;
                  Bit9 : BOOL := TRUE;
                  Bit10 : BOOL := TRUE;
                  Bit11 : BOOL := TRUE;                // 1 = Operator can enable/disable function simulation
                  Bit12 : BOOL := TRUE;                // 1 = Operator can enable/disable counting
                  Bit13 : BOOL := TRUE;
                  Bit14 : BOOL := TRUE;
                  Bit15 : BOOL := TRUE;
                  Bit16 : BOOL := TRUE;
                  Bit17 : BOOL := TRUE;
                  Bit18 : BOOL := TRUE;
                  Bit19 : BOOL := TRUE;
                  Bit20 : BOOL := TRUE;
                  Bit21 : BOOL := TRUE;
                  Bit22 : BOOL := TRUE;
                  Bit23 : BOOL := TRUE;
                  Bit24 : BOOL := TRUE;
                  Bit25 : BOOL := TRUE;
                  Bit26 : BOOL := TRUE;
                  Bit27 : BOOL := TRUE;
                  Bit28 : BOOL := TRUE;
                  Bit29 : BOOL := TRUE;
                  Bit30 : BOOL := TRUE;
                  Bit31 : BOOL := TRUE;
                END_STRUCT;
    dwOS_Perm AT OS_Perm : DWORD;                       // Dword view at OS_Perm
    byteOS_Perm AT OS_Perm : ARRAY[0..3] OF BYTE;       // Byte view at OS_Perm

END_VAR
(*
===============================================================================
*)
VAR_OUTPUT

    PV_Out {
            S7_visible := 'true';
            S7_dynamic := 'true';
            S7_edit := 'para';
            S7_m_c := 'true';
            S7_xm_c := 'Value,true;';
            S7_xqc := 'Value,true;';
            S7_xshortcut := 'Value,Current flow in;';
            S7_xarchive := 'Value,false;'
           } : STRUCT                                   // Current flow out
                 Value : REAL := 0.0;                   // Value
                 ST : BYTE := 16#FF;                    // Signal status
               END_STRUCT;

    CurFlow {
             S7_m_c := 'true';
             S7_dynamic := 'true';
             S7_xm_c := 'Value,true;';
             S7_xqc := 'Value,true;';
             S7_xshortcut := 'Value,Current flow out;';
             S7_xarchive := 'Value,false;'
            } : STRUCT                                  // Material current flow
                  Value : REAL := 0.0;                  // Value
                  ST : BYTE := 16#FF;                   // Signal Status
                END_STRUCT;

    Avg1h {
           S7_m_c := 'true';
           S7_dynamic := 'true';
           S7_xm_c := 'Value,true;';
           S7_xqc := 'Value,true;';
           S7_xshortcut := 'Value,Avg. in 60 min.;';
           S7_xarchive := 'Value,false;'
          } : STRUCT                                    // Moving average of material in the last 60 minutes
                Value : REAL := 0.0;                    // Value
                ST : BYTE := 16#FF;                     // Signal Status
              END_STRUCT;

    CurHour {
             S7_m_c := 'true';
             S7_dynamic := 'true';
             S7_xm_c := 'Value,true;';
             S7_xqc := 'Value,true;';
             S7_xshortcut := 'Value,Current hour;';
             S7_xarchive := 'Value,false;'
            } : STRUCT                                  // The amount of material from the beginning of the hour
                  Value : REAL := 0.0;                  // Value
                  ST : BYTE := 16#FF;                   // Signal Status
                END_STRUCT;

    PrevHour {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Previous hour;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material from the previous hour
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    BfPrHour {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Before prev. hour;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material before previous hour
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    OneHrAgo {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,1 hour ago;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material 1 hour ago
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    CurShift {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Current shift;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material from the beginning of shift
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    PrvShift {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Previous shift;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material for the previous shift
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    CurDay {
            S7_m_c := 'true';
            S7_dynamic := 'true';
            S7_xm_c := 'Value,true;';
            S7_xqc := 'Value,true;';
            S7_xshortcut := 'Value,Current day;';
            S7_xarchive := 'Value,false;'
           } : STRUCT                                   // The amount of material from the beginning of the day
                 Value : REAL := 0.0;                   // Value
                 ST : BYTE := 16#FF;                    // Signal Status
               END_STRUCT;

    PrevDay {
             S7_m_c := 'true';
             S7_dynamic := 'true';
             S7_xm_c := 'Value,true;';
             S7_xqc := 'Value,true;';
             S7_xshortcut := 'Value,Previous day;';
             S7_xarchive := 'Value,false;'
            } : STRUCT                                  // The amount of material for the previous day
                  Value : REAL := 0.0;                  // Value
                  ST : BYTE := 16#FF;                   // Signal Status
                END_STRUCT;

    CurMonth {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Current month;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material from the beginning of the month
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;
                
    PrvMonth {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Previous month;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount of material from the previous month
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    CurYear {
             S7_m_c := 'true';
             S7_dynamic := 'true';
             S7_xm_c := 'Value,true;';
             S7_xqc := 'Value,true;';
             S7_xshortcut := 'Value,Current year;';
             S7_xarchive := 'Value,false;'
            } : STRUCT                                  // The amount of material from the beginning of the year
                  Value : REAL := 0.0;                  // Value
                  ST : BYTE := 16#FF;                   // Signal Status
                END_STRUCT;

    PrevYear {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Previous year;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The amount OF material from the previous year
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    TotalMat {
              S7_m_c := 'true';
              S7_dynamic := 'true';
              S7_xm_c := 'Value,true;';
              S7_xqc := 'Value,true;';
              S7_xshortcut := 'Value,Totalizer;';
              S7_xarchive := 'Value,false;'
             } : STRUCT                                 // The total amount of material
                   Value : REAL := 0.0;                 // Value
                   ST : BYTE := 16#FF;                  // Signal Status
                 END_STRUCT;

    OS_PermOut {
                S7_visible:='false';
                S7_m_c:='true'
               } : DWORD := 16#FFFFFFFF;                // Original operator permissions
    byteOS_PermOut AT OS_PermOut : ARRAY[0..3] OF BYTE; // View at OS_PermOut

    OS_PermLog {
                S7_visible:='false';
                S7_m_c:='true'
               } : DWORD := 16#FFFFFFFF;                // Process manipulated operator permissions
    byteOS_PermLog AT OS_PermLog : ARRAY[0..3] OF BYTE; // View at OS_PermLog

    ST_Worst {
              S7_visible:='false';
              S7_m_c:='true'
             } : BYTE := 16#80;                         // Worst Signal Status

    Status1 {
             S7_m_c := 'true';
             S7_visible := 'false';
             S7_dynamic := 'true'
            } : DWORD := 16#00000000;                   // Status 1
    byteStatus1 AT Status1 : ARRAY[0..3] OF BYTE;

    Status2 {
             S7_m_c := 'true';
             S7_visible := 'false';
             S7_dynamic := 'true'
            } : DWORD := 16#00000000;                   // Status 2 - Not used, reserved for future
    byteStatus2 AT Status2 : ARRAY[0..3] OF BYTE;

END_VAR
(*
===============================================================================
*)
VAR

    TicksPerSec : INT := 1;
    CurTick : INT := 0;
    SuprTime : REAL := 0.0;                             // False hour adjustments suppression time span
    MatPerTicks : REAL;

    Cur_Hour : STRUCT
                 DI_Part : DINT := 0;
                 Re_Part : REAL := 0.0;
               END_STRUCT;

    Cur_Shift : STRUCT
                  DI_Part : DINT := 0;
                  Re_Part : REAL := 0.0;
                END_STRUCT;

    Cur_Day : STRUCT
                DI_Part : DINT := 0;
                Re_Part : REAL := 0.0;
              END_STRUCT;

    Cur_Month : STRUCT
                  DI_Part : DINT := 0;
                  Re_Part : REAL := 0.0;
                END_STRUCT;

    Cur_Year : STRUCT
                 DI_Part : DINT := 0;
                 Re_Part : REAL := 0.0;
               END_STRUCT;

    Total : STRUCT
              DI_Part : DINT := 0;
              Re_Part : REAL := 0.0;
            END_STRUCT;

    Loc_DT : DT;
    Loc_DT_STRUCT AT Loc_DT : STRUCT
        Year : BYTE;
        Month : BYTE;
        Day : BYTE;
        Hour : BYTE;
        Minute : BYTE;
        Second : BYTE;
        ms1 : BYTE;
        ms2w : BYTE;
    END_STRUCT;
        
    PrevValues : ARRAY[0..SecArray] OF REAL;          // Historical values array

END_VAR
(*
===============================================================================
*)
VAR_TEMP

    RetValue : INT;
    MatPerSec : REAL;
    MatPerHour : REAL;
    Zero : REAL;
    tTrunc : DINT;
    CurrPnt : INT;
    CountEn : BOOL;

    Actual : STRUCT
        Value : REAL;
        ST : BYTE;
    END_STRUCT;

    UTC_DT : DT;
    UTC_DT_STRUCT AT UTC_DT : STRUCT
        Year : BYTE;
        Month : BYTE;
        Day : BYTE;
        Hour : BYTE;
        Minute : BYTE;
        Second : BYTE;
        ms1 : BYTE;
        ms2w : BYTE;
    END_STRUCT;

    TOP_SI: STRUCT                                      // Startinfo: read info of calling OB
        EV_CLASS :BYTE;
        EV_NUM :BYTE;
        PRIORITY :BYTE;
        NUM :BYTE;
        TYP2_3 :BYTE;
        TYP1 :BYTE;
        ZI1 :WORD;
        ZI2_3 :DWORD;
    END_STRUCT;

    START_UP_SI: STRUCT                                 // Startinfo: read info of recent Start-OB
        EV_CLASS :BYTE;
        EV_NUM :BYTE;
        PRIORITY :BYTE;
        NUM :BYTE;
        TYP2_3 :BYTE;
        TYP1 :BYTE;
        ZI1 :WORD;
        ZI2_3 :DWORD;
    END_STRUCT;

    tbitOS_PermLog : STRUCT
                  Bit0 : BOOL;
                  Bit1 : BOOL;
                  Bit2 : BOOL;
                  Bit3 : BOOL;
                  Bit4 : BOOL;
                  Bit5 : BOOL;                          // 1 = Operator can reset the totalizers
                  Bit6 : BOOL;                          // 1 = Operator can change the simulation value SimPV
                  Bit7 : BOOL;
                  Bit8 : BOOL;
                  Bit9 : BOOL;
                  Bit10 : BOOL;
                  Bit11 : BOOL;                         // 1 = Operator can enable/disable simulation
                  Bit12 : BOOL;                         // 1 = Operator can enable/disable counting
                  Bit13 : BOOL;
                  Bit14 : BOOL;
                  Bit15 : BOOL;
                  Bit16 : BOOL;
                  Bit17 : BOOL;
                  Bit18 : BOOL;
                  Bit19 : BOOL;
                  Bit20 : BOOL;
                  Bit21 : BOOL;
                  Bit22 : BOOL;
                  Bit23 : BOOL;
                  Bit24 : BOOL;
                  Bit25 : BOOL;
                  Bit26 : BOOL;
                  Bit27 : BOOL;
                  Bit28 : BOOL;
                  Bit29 : BOOL;
                  Bit30 : BOOL;
                  Bit31 : BOOL;
    END_STRUCT;
    tdwOS_PermLog AT tbitOS_PermLog : DWORD;
    tbyteOS_PermLog AT tbitOS_PermLog : ARRAY[0..3] OF BYTE;

    tStatus1 : STRUCT                                   // Status 1
                Bit0 : BOOL;                            // Count enabled
                Bit1 : BOOL;                            // BatchEn - Not implemented!
                Bit2 : BOOL;                            // SimOn
                Bit3 : BOOL;                            // OosAct.Value - Not implemented!
                Bit4 : BOOL;                            // OosLi.Value - Not implemented!
                Bit5 : BOOL;                            // Not used
                Bit6 : BOOL;                            // OnAct.Value - NOT implemented!
                Bit7 : BOOL;                            // Not used
                Bit8 : BOOL;                            // Not used
                Bit9 : BOOL;                            // Not used
                Bit10 : BOOL;                           // SimLiOp.Value
                Bit11 : BOOL;                           // Delay of the PV_AH_Lim message - Not implemented!
                Bit12 : BOOL;                           // Delay of the PV_WH_Lim message - Not implemented!
                Bit13 : BOOL;                           // Delay of the PV_TH_Lim message - Not implemented!
                Bit14 : BOOL;                           // Delay of the PV_TL_Lim message - Not implemented!
                Bit15 : BOOL;                           // Delay of the PV_WL_Lim message - Not implemented!
                Bit16 : BOOL;                           // Delay of the PV_AL_Lim message - Not implemented!
                Bit17 : BOOL;                           // Collection of message delays - NOT implemented!
                Bit18 : BOOL;                           // 1 = Suppessing hour transition is active
                Bit19 : BOOL;                           // 1 = New hour has begun (impulse for one tick)
                Bit20 : BOOL;                           // 1 = New shift has begun (impulse for one tick)
                Bit21 : BOOL;                           // 1 = New day has begun (impulse for one tick)
                Bit22 : BOOL;                           // 1 = New month has begun (impulse for one tick)
                Bit23 : BOOL;                           // 1 = New year has begun (impulse for one tick)
                Bit24 : BOOL;                           // Not used
                Bit25 : BOOL;                           // Not used
                Bit26 : BOOL;                           // Not used
                Bit27 : BOOL;                           // Not used
                Bit28 : BOOL;                           // Not used
                Bit29 : BOOL;                           // 1 = DST is active
                Bit30 : BOOL;                           // Auxiliary value 1 visible
                Bit31 : BOOL;                           // Auxiliary value 2 visible
    END_STRUCT;
    tByteStatus1 AT tStatus1 : ARRAY[0..3] OF BYTE;

    tStatus2 : STRUCT                                   // Status 2 - Not used, reserved for future 
                Bit0 : BOOL;
                Bit1 : BOOL;
                Bit2 : BOOL;
                Bit3 : BOOL;
                Bit4 : BOOL;
                Bit5 : BOOL;
                Bit6 : BOOL;
                Bit7 : BOOL;
                Bit8 : BOOL;
                Bit9 : BOOL;
                Bit10 : BOOL;
                Bit11 : BOOL;
                Bit12 : BOOL;
                Bit13 : BOOL;
                Bit14 : BOOL;
                Bit15 : BOOL;
                Bit16 : BOOL;
                Bit17 : BOOL;
                Bit18 : BOOL;
                Bit19 : BOOL;
                Bit20 : BOOL;
                Bit21 : BOOL;
                Bit22 : BOOL;
                Bit23 : BOOL;
                Bit24 : BOOL;
                Bit25 : BOOL;
                Bit26 : BOOL;
                Bit27 : BOOL;
                Bit28 : BOOL;
                Bit29 : BOOL;
                Bit30 : BOOL;
                Bit31 : BOOL;
    END_STRUCT;
    tByteStatus2 AT tStatus2 : ARRAY[0..3] OF BYTE;

END_VAR
(*
===============================================================================
*)
BEGIN
// Подготовительные операции
    Zero := 0.0;

// Копируем существующие статусы во временные с разворотом x86->S7
    tByteStatus1[0] := byteStatus1[3];
    tByteStatus1[1] := byteStatus1[2];
    tByteStatus1[2] := byteStatus1[1];
    tByteStatus1[3] := byteStatus1[0];
    
    tByteStatus2[0] := byteStatus2[3];
    tByteStatus2[1] := byteStatus2[2];
    tByteStatus2[2] := byteStatus2[1];
    tByteStatus2[3] := byteStatus2[0];
    
    RetValue := RD_SINFO(TOP_SI := TOP_SI, START_UP_SI := START_UP_SI);
    
// Если вызов идёт из OB100 и включена инициализация, то всё обнуляем и выходим
    IF TOP_SI.NUM = 100 AND NOT Feature.Bit0 THEN
        CurHour.Value := 0.0;
        CurHour.ST := 16#80;
        CurShift.Value := 0.0;
        CurShift.ST := 16#80;
        CurDay.Value := 0.0;
        CurDay.ST := 16#80;
        CurMonth.Value := 0.0;
        CurMonth.ST := 16#80;
        CurYear.Value := 0.0;
        CurYear.ST := 16#80;
        RetValue := FILL(BVAL := Zero, BLK := PrevValues);
        OneHrAgo.ST := 16#80;
        Avg1h.Value := 0.0;
        Avg1h.ST := 16#80;
        PrevHour.Value := 0.0;
        PrevHour.ST := 16#80;
        PrvShift.Value := 0.0;
        PrvShift.ST := 16#80;
        PrevDay.Value := 0.0;
        PrevDay.ST := 16#80;
        PrvMonth.Value := 0.0;
        PrvMonth.ST := 16#80;
        PrevYear.Value := 0.0;
        PrevYear.ST := 16#80;
        TotalMat.Value := 0.0;
        TotalMat.ST := 16#80;
        Cur_Hour.DI_Part := 0;
        Cur_Hour.Re_Part := 0.0;
        Cur_Shift.DI_Part := 0;
        Cur_Shift.Re_Part := 0.0;
        Cur_Day.DI_Part := 0;
        Cur_Day.Re_Part := 0.0;
        Cur_Month.DI_Part := 0;
        Cur_Month.Re_Part := 0.0;
        Cur_Year.DI_Part := 0;
        Cur_Year.Re_Part := 0.0;
        Total.DI_Part := 0;
        Total.Re_Part := 0.0;
        CurTick := 0;
        MatPerTicks := 0.0;
        MatPerSec := 0.0;
        SuprTime := 0.0;
        Status1 := 16#00000000;
        Status2 := 16#00000000;
        RETURN;
    END_IF;

// Разбираемся с OS_Perm
    tdwOS_PermLog := dwOS_Perm;

    tbitOS_PermLog.Bit5 := OS_Perm.Bit5 AND ((RstLi.ST = 16#FF) OR Feature.Bit5);
    tbitOS_PermLog.Bit6 := SimOn AND OS_Perm.Bit6 AND NOT SimLiOp.Value;                            // Сделано по аналогии с исходником MonAnL
    tbitOS_PermLog.Bit7 := CntEn AND OS_Perm.Bit7 AND NOT CntLiOp.Value AND (CntEnLi.ST = 16#FF);   // Сделано по аналогии с исходником MonAnL
    tbitOS_PermLog.Bit11 := OS_Perm.Bit11 AND NOT SimLiOp.Value;                                    // Сделано по аналогии с исходником MonAnL
    tBitOS_PermLog.Bit12 := OS_Perm.Bit12 AND NOT CntLiOp.Value;                                    // Сделано по аналогии с исходником MonAnL

    byteOS_PermOut[3] := byteOS_Perm[0];
    byteOS_PermOut[2] := byteOS_Perm[1];
    byteOS_PermOut[1] := byteOS_Perm[2];
    byteOS_PermOut[0] := byteOS_Perm[3];

    byteOS_PermLog[3] := tbyteOS_PermLog[0];
    byteOS_PermLog[2] := tbyteOS_PermLog[1];
    byteOS_PermLog[1] := tbyteOS_PermLog[2];
    byteOS_PermLog[0] := tbyteOS_PermLog[3];    

// Получаем текущее время в UTC
    RetValue := READ_CLK(CDT := UTC_DT);
    
// Каждую минуту вызываем коррекцию в локальный часовой пояс
// А если включен DST, то дополнительно прибавляем "летнее время" и включаем бит в слове статусов
    IF UTC_DT_Struct.Second = 0 THEN
        Loc_DT := AD_DT_TM_APL(T := UTC_DT, D := TZOffset);
        IF DSTEn AND (GE_DT_APL(DT1 := Loc_DT, DT2 := DSTBegin) AND LT_DT_APL(DT1 := Loc_DT, DT2 := DSTEnd)) THEN
            Loc_DT := AD_DT_TM_APL(T := Loc_DT, D := DSTOffset);
            tStatus1.Bit29 := TRUE;
        ELSE
            tStatus1.Bit29 := FALSE;
        END_IF;
    END_IF;
    
// Секунды и миллисекунды просто копируем из UTC в Local, они всегда одинаковые
    Loc_DT_Struct.Second := UTC_DT_Struct.Second;
    Loc_DT_Struct.ms1 := UTC_DT_Struct.ms1;

// Счёт разрешён, если:
// Оператор включил счёт И выбран режим от оператора
// ИЛИ
// Есть линкованный сигнал И выбран режим линкованного сигнала
    CountEn := (CntEn AND NOT CntLiOp.Value) OR (CntEnLi.Value AND CntLiOp.Value);
// Если CountEn = 0, то счёт отключен
    IF NOT CountEn THEN
        RETURN;
    END_IF;

// Получаем кол-во вызовов блока (тиков) за одну секунду
// Так как теоретически вызов блока может быть засунут в OB3x с интервалами 2, 5 и 10 секунд, то возможно TicksPerSec = 0
    TicksPerSec := REAL_TO_INT(1.0 / SampleTime);
    
// Увеличиваем номер текущего тика
    CurTick := CurTick + 1;

// Если подавление ошибочного перехода часа активно, то блокируем попытки обнуления часа на SecToSuppress секунд
    IF tStatus1.Bit18 THEN
        SuprTime := SuprTime + SampleTime;
        IF SuprTime >= SecToSuppress THEN
            tStatus1.Bit18 := FALSE;
            SuprTime := 0.0;
        END_IF;
    END_IF;

// Проверяем, не сменились ли час, смена, день, месяц, год
// Признак смены часа не будет устанавливаться, если час менялся менее SecToSuppress секунд назад
// Защита от коррекции времени
    tStatus1.Bit19 := (Loc_DT_Struct.Minute = 0) AND (Loc_DT_Struct.Second = 0) AND NOT tStatus1.Bit18;
// Бит новой смены, если час = 8 или 20 и час сменился
    tStatus1.Bit20 := ((Loc_DT_Struct.Hour = 8) OR (Loc_DT_Struct.Hour = INT_TO_BCD(20))) AND tStatus1.Bit19;
// Бит новых суток, если час = ChkoutHr и час сменился
    tStatus1.Bit21 := (BCD_TO_INT(Loc_DT_Struct.Hour) = ChkOutHr) AND tStatus1.Bit19;
// Бит нового месяца, если день = 1 и день сменился
    tStatus1.Bit22:= (Loc_DT_Struct.Day = 1) AND tStatus1.Bit21;
// Бит нового года, если месяц = 1 и месяц сменился
    tStatus1.Bit23 := (Loc_DT_Struct.Month = 1) AND tStatus1.Bit22;
    
// Обнуление счётчиков при смене часа, смены, суток и месяца делаем только один раз, в первом тике
    IF CurTick = 1 THEN
// Обнуляем час (если нет подавления)
// Копируем старые значения в час назад и в два часа назад
        IF tStatus1.Bit19 THEN
            BfPrHour.Value := PrevHour.Value;
            BfPrHour.ST := PrevHour.ST;
            PrevHour.Value := CurHour.Value;
            PrevHour.ST := CurHour.ST;
            CurHour.Value := 0.0;
            Cur_Hour.DI_Part := 0;
            Cur_Hour.Re_Part := 0.0;
            tStatus1.Bit18 := TRUE;
        END_IF;

// Обнуляем смену и переносим текущее накопление в предыдущие показания
        IF tStatus1.Bit20 THEN
            PrvShift.Value := CurShift.Value;
            PrvShift.ST := CurShift.ST;
            CurShift.Value := 0.0;
            Cur_Shift.DI_Part := 0;
            Cur_Shift.Re_Part := 0.0;
        END_IF;

// Обнуляем день и переносим текущее накопление в предыдущие показания
        IF tStatus1.Bit21 THEN
            PrevDay.Value := CurDay.Value;
            PrevDay.ST := CurDay.ST;
            CurDay.Value := 0.0;
            Cur_Day.DI_Part := 0;
            Cur_Day.Re_Part := 0.0;
        END_IF;

// Обнуляем месяц    
        IF tStatus1.Bit22 THEN
            PrvMonth.Value := CurMonth.Value;
            PrvMonth.ST := CurMonth.ST;
            CurMonth.Value := 0.0;
            Cur_Month.DI_Part := 0;
            Cur_Month.Re_Part := 0.0;
        END_IF;

// Обнуляем год
        IF tStatus1.Bit23 THEN
            PrevYear.Value := CurYear.Value;
            PrevYear.ST := CurYear.ST;
            CurYear.Value := 0.0;
            Cur_Year.DI_Part := 0;
            Cur_Year.Re_Part := 0.0;
        END_IF;

    END_IF;

    Actual.Value := PV.Value;
    Actual.ST := PV.ST;

// Если отрицательные показания недопустимы (Feature.Bit6 = 1) - то выдаём 0.
    IF Actual.Value < 0 AND Feature.Bit6 THEN
        Actual.Value := 0.0;
    END_IF;

// Разбираемся с симуляцией
    IF SimOn AND OS_Perm.Bit11 AND NOT SimLiOp.Value THEN
        Actual.Value := SimPV;
        Actual.ST := 16#60;
    END_IF;
    
    IF SimOnLi.Value AND SimLiOp.Value THEN
        Actual.Value := SimPV_Li.Value;
        Actual.ST := 16#60;
    END_IF;
    
    PV_Out.Value := Actual.Value;
    PV_Out.ST := Actual.ST;
    ST_Worst := Actual.ST;
    
// Накапливаем показания материала по тикам
    MatPerTicks := MatPerTicks + Actual.Value;

// Если тик последний в секунде, значит пора выдавать всё, что насчитали за секунду
    IF CurTick >= TicksPerSec THEN

        MatPerHour := MatPerTicks * SampleTime * TimeCnv / AmountCnv;

        CurFlow.Value := MatPerHour;
        CurFlow.ST := Actual.ST;
                
        Avg1h.Value := (Avg1h.Value * 3599.0 + MatPerHour) / 3600.0;
        Avg1h.ST := Actual.ST;
    
        IF Avg1h.Value < 1e-6 AND MatPerHour = 0.0 THEN
            Avg1h.Value := 0.0;
        END_IF;
    
        MatPerSec := MatPerHour / 3600.0;
    
        Cur_Hour.Re_Part := Cur_Hour.Re_Part + MatPerSec;
        IF Cur_Hour.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Hour.Re_Part);
            Cur_Hour.DI_Part := Cur_Hour.DI_Part + tTrunc;
            Cur_Hour.Re_Part := Cur_Hour.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Hour.DI_Part < 0 THEN
                Cur_Hour.DI_Part := 0;
            END_IF;
        END_IF;
        CurHour.Value := DINT_TO_REAL(Cur_Hour.DI_Part) + Cur_Hour.Re_Part;
        CurHour.ST := Actual.ST;
    
        CurrPnt := BCD_TO_INT(Loc_DT_Struct.Minute) * 60 + BCD_TO_INT(Loc_DT_Struct.Second);
    
        OneHrAgo.Value := PrevValues[CurrPnt];
        OneHrAgo.ST := Actual.ST;
        
        PrevValues[CurrPnt] := CurFlow.Value;
    
        Cur_Shift.Re_Part := Cur_Shift.Re_Part + MatPerSec;
        IF Cur_Shift.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Shift.Re_Part);
            Cur_Shift.DI_Part := Cur_Shift.DI_Part + tTrunc;
            Cur_Shift.Re_Part := Cur_Shift.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Shift.DI_Part < 0 THEN
                Cur_Shift.DI_Part := 0;
            END_IF;
        END_IF;
        CurShift.Value := DINT_TO_REAL(Cur_Shift.DI_Part) + Cur_Shift.Re_Part;
        CurShift.ST := Actual.ST;
    
        Cur_Day.Re_Part := Cur_Day.Re_Part + MatPerSec;
        IF Cur_Day.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Day.Re_Part);
            Cur_Day.DI_Part := Cur_Day.DI_Part + tTrunc;
            Cur_Day.Re_Part := Cur_Day.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Day.DI_Part < 0 THEN
                Cur_Day.DI_Part := 0;
            END_IF;
        END_IF;
        CurDay.Value := DINT_TO_REAL(Cur_Day.DI_Part) + Cur_Day.Re_Part;
        CurDay.ST := Actual.ST;

        Cur_Month.Re_Part := Cur_Month.Re_Part + MatPerSec;
        IF Cur_Month.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Month.Re_Part);
            Cur_Month.DI_Part := Cur_Month.DI_Part + tTrunc;
            Cur_Month.Re_Part := Cur_Month.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Month.DI_Part < 0 THEN
                Cur_Month.DI_Part := 0;
            END_IF;
        END_IF;
        CurMonth.Value := DINT_TO_REAL(Cur_Month.DI_Part) + Cur_Month.Re_Part;
        CurMonth.ST := Actual.ST;

        Cur_Year.Re_Part := Cur_Year.Re_Part + MatPerSec;
        IF Cur_Year.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Year.Re_Part);
            Cur_Year.DI_Part := Cur_Year.DI_Part + tTrunc;
            Cur_Year.Re_Part := Cur_Year.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Year.DI_Part < 0 THEN
                Cur_Year.DI_Part := 0;
            END_IF;
        END_IF;
        CurYear.Value := DINT_TO_REAL(Cur_Year.DI_Part) + Cur_Year.Re_Part;
        CurYear.ST := Actual.ST;

        Total.Re_Part := Total.Re_Part + MatPerSec;
        IF Total.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Total.Re_Part);
            Total.DI_Part := Total.DI_Part + tTrunc;
            Total.Re_Part := Total.Re_Part - DINT_TO_REAL(tTrunc);
            IF Total.DI_Part < 0 THEN
                Total.DI_Part := 0;
            END_IF;
        END_IF;
        TotalMat.Value := DINT_TO_REAL(Total.DI_Part) + Total.Re_Part;
        TotalMat.ST := Actual.ST;
        
        CurTick := 0;
        MatPerTicks := 0.0;
        
// Обрабатываем сбросы: операторский при наличии разрешения или линкованный
        IF (RstOp AND tbitOS_PermLog.Bit5) OR RstLi.Value THEN
            CurHour.Value := 0.0;
            CurHour.ST := 16#80;
            CurShift.Value := 0.0;
            CurShift.ST := 16#80;
            CurDay.Value := 0.0;
            CurDay.ST := 16#80;
            CurMonth.Value := 0.0;
            CurMonth.ST := 16#80;
            CurYear.Value := 0.0;
            CurYear.ST := 16#80;
            Cur_Hour.DI_Part := 0;
            Cur_Hour.Re_Part := 0.0;
            Cur_Shift.DI_Part := 0;
            Cur_Shift.Re_Part := 0.0;
            Cur_Day.DI_Part := 0;
            Cur_Day.Re_Part := 0.0;
            Cur_Month.DI_Part := 0;
            Cur_Month.Re_Part := 0.0;
            Cur_Year.DI_Part := 0;
            Cur_Year.Re_Part := 0.0;
            IF Feature.Bit1 THEN
                RetValue := FILL(BVAL := Zero, BLK := PrevValues);
                OneHrAgo.ST := 16#80;
            END_IF;
            IF Feature.Bit2 THEN
                Avg1h.Value := 0.0;
                Avg1h.ST := 16#80;
            END_IF;
            IF Feature.Bit3 THEN
                PrevHour.Value := 0.0;
                PrevHour.ST := 16#80;
                PrvShift.Value := 0.0;
                PrvShift.ST := 16#80;
                PrevDay.Value := 0.0;
                PrevDay.ST := 16#80;
                PrvMonth.Value := 0.0;
                PrvMonth.ST := 16#80;
                PrevYear.Value := 0.0;
                PrevYear.ST := 16#80;
            END_IF;
            IF Feature.Bit4 THEN
                TotalMat.Value := 0.0;
                TotalMat.ST := 16#80;
                Total.DI_Part := 0;
                Total.Re_Part := 0.0;
            END_IF;
            IF RstOp THEN
                RstOp := FALSE;
            END_IF;
        END_IF;

    END_IF;

// Выставляем биты в слове статуса
    tStatus1.Bit0 := CountEn;
    tStatus1.Bit2 := SimOn;
    tStatus1.Bit10 := SimLiOp.Value;
    tStatus1.Bit30 := (UserAna1.ST <> 16#FF);
    tStatus1.Bit31 := (UserAna2.ST <> 16#FF);

// Копируем временные статусы в выходные с разворотом S7->x86
    byteStatus1[0] := tByteStatus1[3];
    byteStatus1[1] := tByteStatus1[2];
    byteStatus1[2] := tByteStatus1[1];        
    byteStatus1[3] := tByteStatus1[0];

// Копируем временные статусы в выходные с разворотом S7->x86
    byteStatus2[0] := tByteStatus2[3];
    byteStatus2[1] := tByteStatus2[2];
    byteStatus2[2] := tByteStatus2[1];        
    byteStatus2[3] := tByteStatus2[0];
    
END_FUNCTION_BLOCK
