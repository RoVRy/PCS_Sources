FUNCTION_BLOCK MatStat { S7_m_c := 'true';
                         S7_blockview := 'big';
                         S7_read_back := 'true';
                         S7_tasklist := 'OB100';
                         Scl_OverwriteBlocks := 'y';
                         Scl_CreateObjectCode := 'y';
                         Scl_OptimizeObjectCode := 'y';
                         Scl_MonitorArrayLimits := 'n';
                         Scl_CreateDebugInfo := 'n';
                         Scl_S7ServerActive := 'n';
                         GenerateReferenceData := 'y';
                         SetMaximumStringLength := '254' }
TITLE = 'Material flow stats'
VERSION: '2.10'
AUTHOR: AdvLibRR
NAME: MatStat
FAMILY: Count
KNOW_HOW_PROTECT
(*
=======================================================================================================================
Блок в своей работе использует системные функции:
SFC1 "READ_CLK"
SFC6 "RD_SINFO"
=======================================================================================================================
*)
CONST

    SecArray := 3600;
    SecToSuppress := 300.0;

END_CONST


VAR_INPUT

    PV          { S7_visible := 'true';
                  S7_dynamic := 'true';
                  S7_m_c := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;' }         : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Current flow in

    PV_Unit     { S7_m_c := 'true';
                  S7_visible := 'true';
                  S7_unit := '' }                   : INT := 1322;                  // Unit of PV

    Flow_Unit   { S7_m_c := 'true';
                  S7_visible := 'true';
                  S7_unit := '' }                   : INT := 1328;                  // Material flow measure unit

    All_Unit    { S7_m_c := 'true';
                  S7_visible := 'true';
                  S7_unit := '' }                   : INT := 1092;                  // Material measure unit

    TimeCnv     { S7_visible := 'true' }            : REAL := 3600.0;               // "Time in" to "Time out" factor

    AmountCnv   { S7_visible := 'true' }            : REAL := 1000.0;               // "Amount in' to "Amount out" factor

    TZOffset    { S7_visible := 'false' }           : TIME := T#9H;                 // Time Zone offset for Standard Time

    DSTEn       { S7_visible := 'false' }           : BOOL := FALSE;                // Enable DST advancing during the year

    DSTBegin    { S7_visible := 'false' }           : DATE_AND_TIME;                // Date and time for switch to DST

    DSTEnd      { S7_visible := 'false' }           : DATE_AND_TIME;                // Date and time for return to Standard Time

    DSTOffset   { S7_visible := 'false' }           : TIME := T#1H;                 // DST shift

    ChkoutHr    { S7_visible := 'false' }           : INT := 10;                    // Checkout hour (necessary for energy accounting)

    ShiftHBegin { S7_visible := 'false' }           : INT := 7;                     // Shift begin hour
    
    ShiftMBegin { S7_visible := 'false' }           : INT := 0;                     // Shift begin minutes

    ShiftHEnd   { S7_visible := 'false' }           : INT := 19;                    // Shift end hour

    ShiftMEnd   { S7_visible := 'false' }           : INT := 0;                     // Shift end minutes

    CntLiOp     { S7_visible := 'true' }            : STRUCT
        Value   : BOOL := FALSE;                                                    // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Count enable via 0 = Operator, 1 = Interconnection or SFC
                
    CntEnLi     { S7_visible := 'true' }            : STRUCT
        Value   : BOOL := TRUE;                                                     // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // 1 = Count enabled by interconnection or SFC (controlled by CntLiOp = 1)

    CntEn       { S7_visible := 'false';
                  S7_link := 'false';
                  Op_Level := '2';
                  S7_m_c := 'true' }                : BOOL := TRUE;                 // Count enabled from operator

    SimLiOp     { S7_visible := 'true' }            : STRUCT
        Value   : BOOL := FALSE;                                                    // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Simulation on/off via 0 = Operator, 1 = Interconnection or SFC

    SimOnLi     { S7_visible := 'true' }            : STRUCT
        Value   : BOOL := FALSE;                                                    // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // 1 = Simulation activated by interconnection or SFC (controlled by SimLiOp = 1)

    SimOn       { S7_visible := 'false';
                  S7_link := 'false';
                  Op_Level := '3';
                  S7_m_c := 'true' }                : BOOL := FALSE;                // Simulation On/Off

    SimPV_Li    { S7_visible := 'true' }            : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Linkable simulation value of weight

    SimPV       { S7_visible := 'false';
                  S7_link := 'false';
                  S7_m_c := 'true';
                  Op_Level := '3' }                 : REAL := 0.0;                  // Simulation Value

    RstLi       { S7_visible := 'true' }            : STRUCT
        Value   : BOOL := FALSE;                                                    // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Immediate reset all totalizers from external code

    RstOp       { S7_m_c := 'true';
                  S7_link := 'false';
                  S7_visible := 'false';
                  Op_Level := '2' }                 : BOOL := FALSE;                // Immediate reset all totalizers from faceplate

    UserAna1    { S7_m_c := 'true';
                  S7_visible := 'false';
                  S7_xm_c:='Value,true;';
                  S7_xqc:='Value,true;';
                  S7_xshortcut := 'Value,;' }       : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // User analog input 1

    UA1Unit     { S7_visible := 'false';
                  S7_m_c := 'true';
                  S7_unit := '' }                   : INT := 0;                     // Unit OF UserAna1

    UserAna2    { S7_m_c := 'true';
                  S7_visible := 'false';
                  S7_xm_c:='Value,true;';
                  S7_xqc:='Value,true;';
                  S7_xshortcut := 'Value,;' }       : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // User analog input 2

    UA2Unit     { S7_visible := 'false';
                  S7_m_c := 'true';
                  S7_unit := '' }                   : INT := 0;                     // Unit of UserAna2

    SampleTime  { S7_sampletime := 'true';
                  S7_visible := 'false';
                  S7_link := 'false' }              : REAL := 1.0 ;                 // Sampling time [s]

    SelFp1      { BLK_Jump := '1';
                  S7_visible := 'false' }           : ANY;                          // Select Faceplate 1

    SelFp2      { BLK_Jump := '1';
                  S7_visible := 'false' }           : ANY;                          // Select Faceplate 2

    Feature     { S7_visible := 'false' }           : STRUCT
        Bit0    : BOOL := TRUE;                                                     // 0 = Reset all values; 1 = keep last stored values
        Bit1    : BOOL := FALSE;                                                    // 1 = RstOp/RstLi also resets two hours all historical values
        Bit2    : BOOL := FALSE;                                                    // 1 = RstOp/RstLi also resets moving average value
        Bit3    : BOOL := FALSE;                                                    // 1 = RstOp/RstLi also resets all previous values
        Bit4    : BOOL := FALSE;                                                    // 1 = RstOp/RstLi also resets total value
        Bit5    : BOOL := FALSE;                                                    // 0 = Linked RstLi will block RstOp, 1 = RstLi and RstOp works side by side
        Bit6    : BOOL := FALSE;                                                    // 1 = All negative values will be substituted by zero
        Bit7    : BOOL := FALSE;                                                    // Not used
        Bit8    : BOOL := FALSE;                                                    // Not used
        Bit9    : BOOL := FALSE;                                                    // Not used
        Bit10   : BOOL := FALSE;                                                    // Not used
        Bit11   : BOOL := FALSE;                                                    // Not used
        Bit12   : BOOL := FALSE;                                                    // Not used
        Bit13   : BOOL := FALSE;                                                    // Not used
        Bit14   : BOOL := FALSE;                                                    // Not used
        Bit15   : BOOL := FALSE;                                                    // Not used
        Bit16   : BOOL := FALSE;                                                    // Not used
        Bit17   : BOOL := FALSE;                                                    // Not used
        Bit18   : BOOL := FALSE;                                                    // Not used
        Bit19   : BOOL := FALSE;                                                    // Not used
        Bit20   : BOOL := FALSE;                                                    // Not used
        Bit21   : BOOL := FALSE;                                                    // Not used
        Bit22   : BOOL := FALSE;                                                    // Not used
        Bit23   : BOOL := FALSE;                                                    // Not used
        Bit24   : BOOL := FALSE;                                                    // Not used
        Bit25   : BOOL := FALSE;                                                    // Not used
        Bit26   : BOOL := FALSE;                                                    // Not used
        Bit27   : BOOL := FALSE;                                                    // Not used
        Bit28   : BOOL := FALSE;                                                    // Not used
        Bit29   : BOOL := FALSE;                                                    // Not used
        Bit30   : BOOL := FALSE;                                                    // Not used
        Bit31   : BOOL := FALSE;                                                    // Not used
    END_STRUCT;                                                                     // Status of various features

    OS_Perm     { S7_visible := 'false' }           : STRUCT
        Bit0    : BOOL := TRUE;                                                     // Not used
        Bit1    : BOOL := TRUE;                                                     // Not used
        Bit2    : BOOL := TRUE;                                                     // Not used
        Bit3    : BOOL := TRUE;                                                     // Not used
        Bit4    : BOOL := TRUE;                                                     // Not used
        Bit5    : BOOL := TRUE;                                                     // 1 = Operator can reset the totalizers
        Bit6    : BOOL := TRUE;                                                     // 1 = Operator can change the simulation value SimPV
        Bit7    : BOOL := TRUE;                                                     // Not used
        Bit8    : BOOL := TRUE;                                                     // Not used
        Bit9    : BOOL := TRUE;                                                     // Not used
        Bit10   : BOOL := TRUE;                                                     // Not used
        Bit11   : BOOL := TRUE;                                                     // 1 = Operator can enable/disable function simulation
        Bit12   : BOOL := TRUE;                                                     // 1 = Operator can enable/disable counting
        Bit13   : BOOL := TRUE;                                                     // Not used
        Bit14   : BOOL := TRUE;                                                     // Not used
        Bit15   : BOOL := TRUE;                                                     // Not used
        Bit16   : BOOL := TRUE;                                                     // Not used
        Bit17   : BOOL := TRUE;                                                     // Not used
        Bit18   : BOOL := TRUE;                                                     // Not used
        Bit19   : BOOL := TRUE;                                                     // Not used
        Bit20   : BOOL := TRUE;                                                     // Not used
        Bit21   : BOOL := TRUE;                                                     // Not used
        Bit22   : BOOL := TRUE;                                                     // Not used
        Bit23   : BOOL := TRUE;                                                     // Not used
        Bit24   : BOOL := TRUE;                                                     // Not used
        Bit25   : BOOL := TRUE;                                                     // Not used
        Bit26   : BOOL := TRUE;                                                     // Not used
        Bit27   : BOOL := TRUE;                                                     // Not used
        Bit28   : BOOL := TRUE;                                                     // Not used
        Bit29   : BOOL := TRUE;                                                     // Not used
        Bit30   : BOOL := TRUE;                                                     // Not used
        Bit31   : BOOL := TRUE;                                                     // Not used
    END_STRUCT;                                                                     // Operator Permissions
    dwOS_Perm AT OS_Perm                            : DWORD;                        // Dword view at OS_Perm
    byteOS_Perm AT OS_Perm                          : ARRAY[0..3] OF BYTE;          // Byte view at OS_Perm

END_VAR
(*
=======================================================================================================================
*)
VAR_OUTPUT

    PV_Out      { S7_visible := 'true';
                  S7_dynamic := 'true';
                  S7_edit := 'para';
                  S7_m_c := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current flow in;';
                  S7_xarchive := 'Value,false;' }   : STRUCT                                   
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal status
    END_STRUCT;                                                                     // Current flow out (Pass-through)

    CurFlow     { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current flow out;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // Material current flow with FlowUnit

    Avg1h       { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Avg. in 60 min.;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // Moving average of material in the last 60 minutes

    CurHour     { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current hour;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the beginning of the hour

    PrevHour    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Previous hour;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the previous hour

    BfPrHour    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Before prev. hour;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material before previous hour

    OneHrAgo    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,1 hour ago;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material 1 hour ago

    CurShift    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current shift;';
                  S7_xarchive := 'Value,false;' }   : STRUCT                                 
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the beginning of shift

    PrvShift    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Previous shift;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material for the previous shift

    CurDay      { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current day;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the beginning of the day

    PrevDay     { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Previous day;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material for the previous day

    CurMonth    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current month;';
                  S7_xarchive := 'Value,false;' }   : STRUCT                                 
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the beginning of the month
                
    PrvMonth    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Previous month;';
                  S7_xarchive := 'Value,false;' }   : STRUCT                                 
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the previous month

    CurYear     { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Current year;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount of material from the beginning of the year

    PrevYear    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Previous year;';
                  S7_xarchive := 'Value,false;' }   : STRUCT
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The amount OF material from the previous year

    TotalMat    { S7_m_c := 'true';
                  S7_dynamic := 'true';
                  S7_xm_c := 'Value,true;';
                  S7_xqc := 'Value,true;';
                  S7_xshortcut := 'Value,Totalizer;';
                  S7_xarchive := 'Value,false;' }   : STRUCT                                 
        Value   : REAL := 0.0;                                                      // Value
        ST      : BYTE := 16#FF;                                                    // Signal Status
    END_STRUCT;                                                                     // The total amount of material

    OS_PermOut  { S7_visible:='false';
                  S7_m_c:='true' }                  : DWORD := 16#FFFFFFFF;         // Original operator permissions
    byteOS_PermOut AT OS_PermOut                    : ARRAY[0..3] OF BYTE;          // View at OS_PermOut

    OS_PermLog  { S7_visible:='false';
                  S7_m_c:='true' }                  : DWORD := 16#FFFFFFFF;         // Process manipulated operator permissions
    byteOS_PermLog AT OS_PermLog                    : ARRAY[0..3] OF BYTE;          // View at OS_PermLog

    ST_Worst    { S7_visible:='false';
                  S7_m_c:='true' }                  : BYTE := 16#80;                // Worst Signal Status

    Status1     { S7_m_c := 'true';
                  S7_visible := 'false';
                  S7_dynamic := 'true' }            : DWORD := 16#00000000;         // Status 1
    byteStatus1 AT Status1                          : ARRAY[0..3] OF BYTE;

    Status2     { S7_m_c := 'true';
                  S7_visible := 'false';
                  S7_dynamic := 'true' }            : DWORD := 16#00000000;         // Status 2 - Not used, reserved for future
    byteStatus2 AT Status2                          : ARRAY[0..3] OF BYTE;

END_VAR
(*
=======================================================================================================================
*)
VAR

    TicksPerSec                                     : INT := 1;
    CurTick                                         : INT := 0;
    SuprTime                                        : REAL := 0.0;                  // False hour adjustments suppression time span
    MatPerTicks : REAL;

    Cur_Hour                                        : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Cur_Shift                                       : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Cur_Day                                         : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Cur_Month                                       : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Cur_Year                                        : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Total                                           : STRUCT
        DI_Part : DINT := 0;
        Re_Part : REAL := 0.0;
    END_STRUCT;

    Loc_DT                                          : DT;
    Loc_DT_STRUCT AT Loc_DT                         : STRUCT
        Year    : BYTE;
        Month   : BYTE;
        Day     : BYTE;
        Hour    : BYTE;
        Minute  : BYTE;
        Second  : BYTE;
        ms1     : BYTE;
        ms2w    : BYTE;
    END_STRUCT;
        
    PrevValues                                      : ARRAY[0..SecArray] OF REAL;   // Historical values array

END_VAR
(*
=======================================================================================================================
*)
VAR_TEMP

    RetValue                                        : INT;
    MatPerSec                                       : REAL;
    MatPerHour                                      : REAL;
    Zero                                            : REAL;
    tTrunc                                          : DINT;
    CurrPnt                                         : INT;
    CountEn                                         : BOOL;

    Actual                                          : STRUCT
        Value   : REAL;
        ST      : BYTE;
    END_STRUCT;

    UTC_DT                                          : DT;
    UTC_DT_STRUCT AT UTC_DT                         : STRUCT
        Year    : BYTE;
        Month   : BYTE;
        Day     : BYTE;
        Hour    : BYTE;
        Minute  : BYTE;
        Second  : BYTE;
        ms1     : BYTE;
        ms2w    : BYTE;
    END_STRUCT;

    TOP_SI                                          : STRUCT                        // Startinfo: read info of calling OB
        EV_CLASS    : BYTE;
        EV_NUM      : BYTE;
        PRIORITY    : BYTE;
        NUM         : BYTE;
        TYP2_3      : BYTE;
        TYP1        : BYTE;
        ZI1         : WORD;
        ZI2_3       : DWORD;
    END_STRUCT;

    START_UP_SI                                     : STRUCT                       // Startinfo: read info of recent Start-OB
        EV_CLASS    : BYTE;
        EV_NUM      : BYTE;
        PRIORITY    : BYTE;
        NUM         : BYTE;
        TYP2_3      : BYTE;
        TYP1        : BYTE;
        ZI1         : WORD;
        ZI2_3       : DWORD;
    END_STRUCT;

    tbitOS_PermLog                                  : STRUCT
        Bit0    : BOOL;
        Bit1    : BOOL;
        Bit2    : BOOL;
        Bit3    : BOOL;
        Bit4    : BOOL;
        Bit5    : BOOL;                                                             // 1 = Operator can reset the totalizers
        Bit6    : BOOL;                                                             // 1 = Operator can change the simulation value SimPV
        Bit7    : BOOL;
        Bit8    : BOOL;
        Bit9    : BOOL;
        Bit10   : BOOL;
        Bit11   : BOOL;                                                             // 1 = Operator can enable/disable simulation
        Bit12   : BOOL;                                                             // 1 = Operator can enable/disable counting
        Bit13   : BOOL;
        Bit14   : BOOL;
        Bit15   : BOOL;
        Bit16   : BOOL;
        Bit17   : BOOL;
        Bit18   : BOOL;
        Bit19   : BOOL;
        Bit20   : BOOL;
        Bit21   : BOOL;
        Bit22   : BOOL;
        Bit23   : BOOL;
        Bit24   : BOOL;
        Bit25   : BOOL;
        Bit26   : BOOL;
        Bit27   : BOOL;
        Bit28   : BOOL;
        Bit29   : BOOL;
        Bit30   : BOOL;
        Bit31   : BOOL;
    END_STRUCT;
    tdwOS_PermLog AT tbitOS_PermLog                 : DWORD;
    tbyteOS_PermLog AT tbitOS_PermLog               : ARRAY[0..3] OF BYTE;

    tStatus1                                        : STRUCT
        Bit0    : BOOL;                                                             // Count enabled
        Bit1    : BOOL;                                                             // BatchEn - Not implemented!
        Bit2    : BOOL;                                                             // SimOn
        Bit3    : BOOL;                                                             // OosAct.Value - Not implemented!
        Bit4    : BOOL;                                                             // OosLi.Value - Not implemented!
        Bit5    : BOOL;                                                             // Not used
        Bit6    : BOOL;                                                             // OnAct.Value - NOT implemented!
        Bit7    : BOOL;                                                             // Not used
        Bit8    : BOOL;                                                             // Not used
        Bit9    : BOOL;                                                             // Not used
        Bit10   : BOOL;                                                             // SimLiOp.Value
        Bit11   : BOOL;                                                             // Delay of the PV_AH_Lim message - Not implemented!
        Bit12   : BOOL;                                                             // Delay of the PV_WH_Lim message - Not implemented!
        Bit13   : BOOL;                                                             // Delay of the PV_TH_Lim message - Not implemented!
        Bit14   : BOOL;                                                             // Delay of the PV_TL_Lim message - Not implemented!
        Bit15   : BOOL;                                                             // Delay of the PV_WL_Lim message - Not implemented!
        Bit16   : BOOL;                                                             // Delay of the PV_AL_Lim message - Not implemented!
        Bit17   : BOOL;                                                             // Collection of message delays - NOT implemented!
        Bit18   : BOOL;                                                             // 1 = Suppessing hour transition is active
        Bit19   : BOOL;                                                             // 1 = New hour has begun (impulse for one tick)
        Bit20   : BOOL;                                                             // 1 = New shift has begun (impulse for one tick)
        Bit21   : BOOL;                                                             // 1 = New day has begun (impulse for one tick)
        Bit22   : BOOL;                                                             // 1 = New month has begun (impulse for one tick)
        Bit23   : BOOL;                                                             // 1 = New year has begun (impulse for one tick)
        Bit24   : BOOL;                                                             // Not used
        Bit25   : BOOL;                                                             // Not used
        Bit26   : BOOL;                                                             // Not used
        Bit27   : BOOL;                                                             // Not used
        Bit28   : BOOL;                                                             // Not used
        Bit29   : BOOL;                                                             // 1 = DST is active
        Bit30   : BOOL;                                                             // Auxiliary value 1 visible
        Bit31   : BOOL;                                                             // Auxiliary value 2 visible
    END_STRUCT;                                                                     // Status 1
    tByteStatus1 AT tStatus1                        : ARRAY[0..3] OF BYTE;

    tStatus2                                        : STRUCT
        Bit0    : BOOL;
        Bit1    : BOOL;
        Bit2    : BOOL;
        Bit3    : BOOL;
        Bit4    : BOOL;
        Bit5    : BOOL;
        Bit6    : BOOL;
        Bit7    : BOOL;
        Bit8    : BOOL;
        Bit9    : BOOL;
        Bit10   : BOOL;
        Bit11   : BOOL;
        Bit12   : BOOL;
        Bit13   : BOOL;
        Bit14   : BOOL;
        Bit15   : BOOL;
        Bit16   : BOOL;
        Bit17   : BOOL;
        Bit18   : BOOL;
        Bit19   : BOOL;
        Bit20   : BOOL;
        Bit21   : BOOL;
        Bit22   : BOOL;
        Bit23   : BOOL;
        Bit24   : BOOL;
        Bit25   : BOOL;
        Bit26   : BOOL;
        Bit27   : BOOL;
        Bit28   : BOOL;
        Bit29   : BOOL;
        Bit30   : BOOL;
        Bit31   : BOOL;
    END_STRUCT;                                                                     // Status 2 - Not used, reserved for future
    tByteStatus2 AT tStatus2                        : ARRAY[0..3] OF BYTE;

END_VAR
(*
=======================================================================================================================
*)
BEGIN
// Подготовительные операции
    Zero := 0.0;

// Копируем существующие статусы во временные с разворотом x86->S7
    tByteStatus1[0] := byteStatus1[3];
    tByteStatus1[1] := byteStatus1[2];
    tByteStatus1[2] := byteStatus1[1];
    tByteStatus1[3] := byteStatus1[0];
    
    tByteStatus2[0] := byteStatus2[3];
    tByteStatus2[1] := byteStatus2[2];
    tByteStatus2[2] := byteStatus2[1];
    tByteStatus2[3] := byteStatus2[0];
    
    RetValue := RD_SINFO(TOP_SI := TOP_SI, START_UP_SI := START_UP_SI);
    
// Если вызов идёт из OB100 и включена инициализация, то всё обнуляем и выходим
    IF TOP_SI.NUM = 100 AND NOT Feature.Bit0 THEN
        CurHour.Value := 0.0;
        CurHour.ST := 16#80;
        CurShift.Value := 0.0;
        CurShift.ST := 16#80;
        CurDay.Value := 0.0;
        CurDay.ST := 16#80;
        CurMonth.Value := 0.0;
        CurMonth.ST := 16#80;
        CurYear.Value := 0.0;
        CurYear.ST := 16#80;
        RetValue := FILL(BVAL := Zero, BLK := PrevValues);
        OneHrAgo.ST := 16#80;
        Avg1h.Value := 0.0;
        Avg1h.ST := 16#80;
        PrevHour.Value := 0.0;
        PrevHour.ST := 16#80;
        PrvShift.Value := 0.0;
        PrvShift.ST := 16#80;
        PrevDay.Value := 0.0;
        PrevDay.ST := 16#80;
        PrvMonth.Value := 0.0;
        PrvMonth.ST := 16#80;
        PrevYear.Value := 0.0;
        PrevYear.ST := 16#80;
        TotalMat.Value := 0.0;
        TotalMat.ST := 16#80;
        Cur_Hour.DI_Part := 0;
        Cur_Hour.Re_Part := 0.0;
        Cur_Shift.DI_Part := 0;
        Cur_Shift.Re_Part := 0.0;
        Cur_Day.DI_Part := 0;
        Cur_Day.Re_Part := 0.0;
        Cur_Month.DI_Part := 0;
        Cur_Month.Re_Part := 0.0;
        Cur_Year.DI_Part := 0;
        Cur_Year.Re_Part := 0.0;
        Total.DI_Part := 0;
        Total.Re_Part := 0.0;
        CurTick := 0;
        MatPerTicks := 0.0;
        MatPerSec := 0.0;
        SuprTime := 0.0;
        Status1 := 16#00000000;
        Status2 := 16#00000000;
        RETURN;
    END_IF;

// Разбираемся с OS_Perm
    tdwOS_PermLog := dwOS_Perm;

    tbitOS_PermLog.Bit5 := OS_Perm.Bit5 AND ((RstLi.ST = 16#FF) OR Feature.Bit5);
    tbitOS_PermLog.Bit6 := SimOn AND OS_Perm.Bit6 AND NOT SimLiOp.Value;                            // Сделано по аналогии с исходником MonAnL
    tbitOS_PermLog.Bit7 := CntEn AND OS_Perm.Bit7 AND NOT CntLiOp.Value AND (CntEnLi.ST = 16#FF);   // Сделано по аналогии с исходником MonAnL
    tbitOS_PermLog.Bit11 := OS_Perm.Bit11 AND NOT SimLiOp.Value;                                    // Сделано по аналогии с исходником MonAnL
    tBitOS_PermLog.Bit12 := OS_Perm.Bit12 AND NOT CntLiOp.Value;                                    // Сделано по аналогии с исходником MonAnL

    byteOS_PermOut[3] := byteOS_Perm[0];
    byteOS_PermOut[2] := byteOS_Perm[1];
    byteOS_PermOut[1] := byteOS_Perm[2];
    byteOS_PermOut[0] := byteOS_Perm[3];

    byteOS_PermLog[3] := tbyteOS_PermLog[0];
    byteOS_PermLog[2] := tbyteOS_PermLog[1];
    byteOS_PermLog[1] := tbyteOS_PermLog[2];
    byteOS_PermLog[0] := tbyteOS_PermLog[3];    

// Получаем текущее время в UTC
    RetValue := READ_CLK(CDT := UTC_DT);
    
// Каждую минуту вызываем коррекцию в локальный часовой пояс
// А если включен DST, то дополнительно прибавляем "летнее время" и включаем бит в слове статусов
    IF UTC_DT_Struct.Second = 0 THEN
        Loc_DT := UTC_DT + TZOffset;
        IF DSTEn AND (UTC_DT >= DSTBegin) AND (UTC_DT < DSTEnd) THEN
            Loc_DT := Loc_DT + DSTOffset;
            tStatus1.Bit29 := TRUE;
        ELSE
            tStatus1.Bit29 := FALSE;
        END_IF;
    END_IF;
    
// Секунды и миллисекунды просто копируем из UTC в Local, они всегда одинаковые
    Loc_DT_Struct.Second := UTC_DT_Struct.Second;
    Loc_DT_Struct.ms1 := UTC_DT_Struct.ms1;

// Счёт разрешён, если:
// Оператор включил счёт И выбран режим от оператора
// ИЛИ
// Есть линкованный сигнал И выбран режим линкованного сигнала
    CountEn := (CntEn AND NOT CntLiOp.Value) OR (CntEnLi.Value AND CntLiOp.Value);
// Если CountEn = 0, то счёт отключен
    IF NOT CountEn THEN
        RETURN;
    END_IF;

// Получаем кол-во вызовов блока (тиков) за одну секунду
// Так как теоретически вызов блока может быть засунут в OB3x с интервалами 2, 5 и 10 секунд, то возможно TicksPerSec = 0
    TicksPerSec := REAL_TO_INT(1.0 / SampleTime);
    
// Увеличиваем номер текущего тика
    CurTick := CurTick + 1;

// Если подавление ошибочного перехода часа активно, то блокируем попытки обнуления часа на SecToSuppress секунд
    IF tStatus1.Bit18 THEN
        SuprTime := SuprTime + SampleTime;
        IF SuprTime >= SecToSuppress THEN
            tStatus1.Bit18 := FALSE;
            SuprTime := 0.0;
        END_IF;
    END_IF;

// Проверяем, не сменились ли час, смена, день, месяц, год
// Признак смены часа не будет устанавливаться, если час менялся менее SecToSuppress секунд назад
// Защита от коррекции времени
    tStatus1.Bit19 := (Loc_DT_Struct.Minute = 0) AND (Loc_DT_Struct.Second = 0) AND NOT tStatus1.Bit18;
// Бит новой смены, если час = 7 или 19 и час сменился
    tStatus1.Bit20 := ( (Loc_DT_Struct.Hour   = INT_TO_BCD(ShiftHBegin)) AND
                        (Loc_DT_Struct.Minute = INT_TO_BCD(ShiftMBegin)) ) OR
                      ( (Loc_DT_Struct.Hour   = INT_TO_BCD(ShiftHEnd)) AND
                        (Loc_DT_Struct.Minute = INT_TO_BCD(ShiftMEnd)) ) AND tStatus1.Bit19;
// Бит новых суток, если час = ChkoutHr и час сменился
    tStatus1.Bit21 := (BCD_TO_INT(Loc_DT_Struct.Hour) = ChkOutHr) AND tStatus1.Bit19;
// Бит нового месяца, если день = 1 и день сменился
    tStatus1.Bit22:= (Loc_DT_Struct.Day = 1) AND tStatus1.Bit21;
// Бит нового года, если месяц = 1 и месяц сменился
    tStatus1.Bit23 := (Loc_DT_Struct.Month = 1) AND tStatus1.Bit22;
    
// Обнуление счётчиков при смене часа, смены, суток и месяца делаем только один раз, в первом тике
    IF CurTick = 1 THEN
// Обнуляем час (если нет подавления)
// Копируем старые значения в час назад и в два часа назад
        IF tStatus1.Bit19 THEN
            BfPrHour.Value := PrevHour.Value;
            BfPrHour.ST := PrevHour.ST;
            PrevHour.Value := CurHour.Value;
            PrevHour.ST := CurHour.ST;
            CurHour.Value := 0.0;
            Cur_Hour.DI_Part := 0;
            Cur_Hour.Re_Part := 0.0;
            tStatus1.Bit18 := TRUE;
        END_IF;

// Обнуляем смену и переносим текущее накопление в предыдущие показания
        IF tStatus1.Bit20 THEN
            PrvShift.Value := CurShift.Value;
            PrvShift.ST := CurShift.ST;
            CurShift.Value := 0.0;
            Cur_Shift.DI_Part := 0;
            Cur_Shift.Re_Part := 0.0;
        END_IF;

// Обнуляем день и переносим текущее накопление в предыдущие показания
        IF tStatus1.Bit21 THEN
            PrevDay.Value := CurDay.Value;
            PrevDay.ST := CurDay.ST;
            CurDay.Value := 0.0;
            Cur_Day.DI_Part := 0;
            Cur_Day.Re_Part := 0.0;
        END_IF;

// Обнуляем месяц    
        IF tStatus1.Bit22 THEN
            PrvMonth.Value := CurMonth.Value;
            PrvMonth.ST := CurMonth.ST;
            CurMonth.Value := 0.0;
            Cur_Month.DI_Part := 0;
            Cur_Month.Re_Part := 0.0;
        END_IF;

// Обнуляем год
        IF tStatus1.Bit23 THEN
            PrevYear.Value := CurYear.Value;
            PrevYear.ST := CurYear.ST;
            CurYear.Value := 0.0;
            Cur_Year.DI_Part := 0;
            Cur_Year.Re_Part := 0.0;
        END_IF;

    END_IF;

    Actual.Value := PV.Value;
    Actual.ST := PV.ST;

// Если отрицательные показания недопустимы (Feature.Bit6 = 1) - то выдаём 0.
    IF Actual.Value < 0 AND Feature.Bit6 THEN
        Actual.Value := 0.0;
    END_IF;

// Разбираемся с симуляцией
    IF SimOn AND OS_Perm.Bit11 AND NOT SimLiOp.Value THEN
        Actual.Value := SimPV;
        Actual.ST := 16#60;
    END_IF;
    
    IF SimOnLi.Value AND SimLiOp.Value THEN
        Actual.Value := SimPV_Li.Value;
        Actual.ST := 16#60;
    END_IF;
    
    PV_Out.Value := Actual.Value;
    PV_Out.ST := Actual.ST;
    ST_Worst := Actual.ST;
    
// Накапливаем показания материала по тикам
    MatPerTicks := MatPerTicks + Actual.Value;

// Если тик последний в секунде, значит пора выдавать всё, что насчитали за секунду
    IF CurTick >= TicksPerSec THEN

        MatPerHour := MatPerTicks * SampleTime * TimeCnv / AmountCnv;

        CurFlow.Value := MatPerHour;
        CurFlow.ST := Actual.ST;
                
        Avg1h.Value := (Avg1h.Value * 3599.0 + MatPerHour) / 3600.0;
        Avg1h.ST := Actual.ST;
    
        IF Avg1h.Value < 1e-6 AND MatPerHour = 0.0 THEN
            Avg1h.Value := 0.0;
        END_IF;
    
        MatPerSec := MatPerHour / 3600.0;
    
        Cur_Hour.Re_Part := Cur_Hour.Re_Part + MatPerSec;
        IF Cur_Hour.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Hour.Re_Part);
            Cur_Hour.DI_Part := Cur_Hour.DI_Part + tTrunc;
            Cur_Hour.Re_Part := Cur_Hour.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Hour.DI_Part < 0 THEN
                Cur_Hour.DI_Part := 0;
            END_IF;
        END_IF;
        CurHour.Value := DINT_TO_REAL(Cur_Hour.DI_Part) + Cur_Hour.Re_Part;
        CurHour.ST := Actual.ST;
    
        CurrPnt := BCD_TO_INT(Loc_DT_Struct.Minute) * 60 + BCD_TO_INT(Loc_DT_Struct.Second);
    
        OneHrAgo.Value := PrevValues[CurrPnt];
        OneHrAgo.ST := Actual.ST;
        
        PrevValues[CurrPnt] := CurFlow.Value;
    
        Cur_Shift.Re_Part := Cur_Shift.Re_Part + MatPerSec;
        IF Cur_Shift.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Shift.Re_Part);
            Cur_Shift.DI_Part := Cur_Shift.DI_Part + tTrunc;
            Cur_Shift.Re_Part := Cur_Shift.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Shift.DI_Part < 0 THEN
                Cur_Shift.DI_Part := 0;
            END_IF;
        END_IF;
        CurShift.Value := DINT_TO_REAL(Cur_Shift.DI_Part) + Cur_Shift.Re_Part;
        CurShift.ST := Actual.ST;
    
        Cur_Day.Re_Part := Cur_Day.Re_Part + MatPerSec;
        IF Cur_Day.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Day.Re_Part);
            Cur_Day.DI_Part := Cur_Day.DI_Part + tTrunc;
            Cur_Day.Re_Part := Cur_Day.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Day.DI_Part < 0 THEN
                Cur_Day.DI_Part := 0;
            END_IF;
        END_IF;
        CurDay.Value := DINT_TO_REAL(Cur_Day.DI_Part) + Cur_Day.Re_Part;
        CurDay.ST := Actual.ST;

        Cur_Month.Re_Part := Cur_Month.Re_Part + MatPerSec;
        IF Cur_Month.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Month.Re_Part);
            Cur_Month.DI_Part := Cur_Month.DI_Part + tTrunc;
            Cur_Month.Re_Part := Cur_Month.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Month.DI_Part < 0 THEN
                Cur_Month.DI_Part := 0;
            END_IF;
        END_IF;
        CurMonth.Value := DINT_TO_REAL(Cur_Month.DI_Part) + Cur_Month.Re_Part;
        CurMonth.ST := Actual.ST;

        Cur_Year.Re_Part := Cur_Year.Re_Part + MatPerSec;
        IF Cur_Year.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Cur_Year.Re_Part);
            Cur_Year.DI_Part := Cur_Year.DI_Part + tTrunc;
            Cur_Year.Re_Part := Cur_Year.Re_Part - DINT_TO_REAL(tTrunc);
            IF Cur_Year.DI_Part < 0 THEN
                Cur_Year.DI_Part := 0;
            END_IF;
        END_IF;
        CurYear.Value := DINT_TO_REAL(Cur_Year.DI_Part) + Cur_Year.Re_Part;
        CurYear.ST := Actual.ST;

        Total.Re_Part := Total.Re_Part + MatPerSec;
        IF Total.Re_Part >= 1.0 THEN
            tTrunc := TRUNC(Total.Re_Part);
            Total.DI_Part := Total.DI_Part + tTrunc;
            Total.Re_Part := Total.Re_Part - DINT_TO_REAL(tTrunc);
            IF Total.DI_Part < 0 THEN
                Total.DI_Part := 0;
            END_IF;
        END_IF;
        TotalMat.Value := DINT_TO_REAL(Total.DI_Part) + Total.Re_Part;
        TotalMat.ST := Actual.ST;
        
        CurTick := 0;
        MatPerTicks := 0.0;
        
// Обрабатываем сбросы: операторский при наличии разрешения или линкованный
        IF (RstOp AND tbitOS_PermLog.Bit5) OR RstLi.Value THEN
            CurHour.Value := 0.0;
            CurHour.ST := 16#80;
            CurShift.Value := 0.0;
            CurShift.ST := 16#80;
            CurDay.Value := 0.0;
            CurDay.ST := 16#80;
            CurMonth.Value := 0.0;
            CurMonth.ST := 16#80;
            CurYear.Value := 0.0;
            CurYear.ST := 16#80;
            Cur_Hour.DI_Part := 0;
            Cur_Hour.Re_Part := 0.0;
            Cur_Shift.DI_Part := 0;
            Cur_Shift.Re_Part := 0.0;
            Cur_Day.DI_Part := 0;
            Cur_Day.Re_Part := 0.0;
            Cur_Month.DI_Part := 0;
            Cur_Month.Re_Part := 0.0;
            Cur_Year.DI_Part := 0;
            Cur_Year.Re_Part := 0.0;
            IF Feature.Bit1 THEN
                RetValue := FILL(BVAL := Zero, BLK := PrevValues);
                OneHrAgo.ST := 16#80;
            END_IF;
            IF Feature.Bit2 THEN
                Avg1h.Value := 0.0;
                Avg1h.ST := 16#80;
            END_IF;
            IF Feature.Bit3 THEN
                PrevHour.Value := 0.0;
                PrevHour.ST := 16#80;
                PrvShift.Value := 0.0;
                PrvShift.ST := 16#80;
                PrevDay.Value := 0.0;
                PrevDay.ST := 16#80;
                PrvMonth.Value := 0.0;
                PrvMonth.ST := 16#80;
                PrevYear.Value := 0.0;
                PrevYear.ST := 16#80;
            END_IF;
            IF Feature.Bit4 THEN
                TotalMat.Value := 0.0;
                TotalMat.ST := 16#80;
                Total.DI_Part := 0;
                Total.Re_Part := 0.0;
            END_IF;
            IF RstOp THEN
                RstOp := FALSE;
            END_IF;
        END_IF;

    END_IF;

// Выставляем биты в слове статуса
    tStatus1.Bit0 := CountEn;
    tStatus1.Bit2 := SimOn;
    tStatus1.Bit10 := SimLiOp.Value;
    tStatus1.Bit30 := (UserAna1.ST <> 16#FF);
    tStatus1.Bit31 := (UserAna2.ST <> 16#FF);

// Копируем временные статусы в выходные с разворотом S7->x86
    byteStatus1[0] := tByteStatus1[3];
    byteStatus1[1] := tByteStatus1[2];
    byteStatus1[2] := tByteStatus1[1];        
    byteStatus1[3] := tByteStatus1[0];

// Копируем временные статусы в выходные с разворотом S7->x86
    byteStatus2[0] := tByteStatus2[3];
    byteStatus2[1] := tByteStatus2[2];
    byteStatus2[2] := tByteStatus2[1];        
    byteStatus2[3] := tByteStatus2[0];
    
END_FUNCTION_BLOCK
